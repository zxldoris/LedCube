#include<reg51.h>
#include<stdlib.h>
#define LED_NUM 53

sbit ADDR0 = P2^0;
sbit ADDR1 = P2^1;
sbit ADDR2 = P2^2;	//74hc138

sbit DS0 = P2^5;	
sbit SHCP = P2^3;	
sbit STCP = P2^4;	//74hc595

sbit Light_Con = P1^5;	//????

void Refresh();
void Timer0Init();
void TransCode();
void LedLocationIntoDatP0();
void VerticalRefresh();

unsigned char code TransCodeChart[256] = {
		0x0, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
		0x8, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
		0x4, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
		0xc, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
		0x2, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
		0xa, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
		0x6, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
		0xe, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
		0x1, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
		0x9, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
		0x5, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
		0xd, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
		0x3, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
		0xb, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
		0x7, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
		0xf, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};

unsigned char code LedLocation[LED_NUM][4]={
	7, 2, 1, 'B',	
	7, 3, 1, 'B',
	7, 4, 1, 'B',
	7, 5, 1, 'B',
	7, 2, 2, 'B',
	7, 2, 3, 'B',
	7, 3, 3, 'B',
	7, 4, 3, 'B',
	7, 5, 3, 'B',
	7, 2, 4, 'B',
	7, 2, 5, 'B',
	7, 3, 5, 'B',
	7, 4, 5, 'B',
	7, 5, 5, 'B',	//'E'
	
	1, 7, 1, 'B',
	1, 7, 1, 'G',
	1, 7, 1, 'R',
	2, 7, 1, 'B',
	2, 7, 1, 'G',
	2, 7, 1, 'R',
	3, 7, 1, 'B',
	3, 7, 1, 'G',
	3, 7, 1, 'R',
	4, 7, 1, 'B',
	4, 7, 1, 'G',
	4, 7, 1, 'R',
	5, 7, 1, 'B',
	5, 7, 1, 'G',
	5, 7, 1, 'R',
	4, 7, 2, 'B',
	4, 7, 2, 'G',
	4, 7, 2, 'R',
	3, 7, 3, 'B',
	3, 7, 3, 'G',
	3, 7, 3, 'R',
	2, 7, 4, 'B',
	2, 7, 4, 'G',
	2, 7, 4, 'R',
	1, 7, 5, 'B',
	1, 7, 5, 'G',
	1, 7, 5, 'R',
	2, 7, 5, 'B',
	2, 7, 5, 'G',
	2, 7, 5, 'R',
	3, 7, 5, 'B',
	3, 7, 5, 'G',
	3, 7, 5, 'R',
	4, 7, 5, 'B',
	4, 7, 5, 'G',
	4, 7, 5, 'R',
	5, 7, 5, 'B',
	5, 7, 5, 'G',
	5, 7, 5, 'R',	//Z
};
unsigned char DatP0[8][24]={
	{ 0xFF, 0xFF, 0xFF, 
	  0xFF, 0xFF, 0xFF, 
	  0xFF, 0xFF, 0xFF,
	  0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF},
	{ 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF},
	{	0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF},
	{ 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF},
	{ 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF},
	{ 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF},
	{	0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF},
	{	0x24, 0x92, 0x49,
		0x24, 0x92, 0x49,
		0x24, 0x92, 0x49,
		0x24, 0x92, 0x49,
		0x24, 0x92, 0x49,
		0x24, 0x92, 0x49,
		0x24, 0x92, 0x49,
		0x24, 0x92, 0x49}
};
static unsigned char x=0, y=0, z=0;
unsigned char color[4] = {'R', 'G', 'B', 'w'};

void main()	//2ms@22.1184MHz
{
	Timer0Init();
	EA = 1;
	ET0 = 1;
	//TR0 = 0;
	switch(colorHorizontal)
	{
		
	}
	HorizontalRefresh(7,colorHorizontal);
	LedLocationIntoDatP0();
	TransCode();
	//TR0 = 1;
	while(1);
}
int FloorScanTimer0() interrupt 1
{
	TR0 = 0;
	TL0 = 0xCD;		//??????
	TH0 = 0xD4;		//??????
	Light_Con = 1;
	switch (z)
    {
	    case 0: ADDR2=0; ADDR1=0; ADDR0=0; Refresh(); z++; break;
	    case 1: ADDR2=0; ADDR1=0; ADDR0=1; Refresh(); z++; break;
	    case 2: ADDR2=0; ADDR1=1; ADDR0=0; Refresh(); z++; break;
	    case 3: ADDR2=0; ADDR1=1; ADDR0=1; Refresh(); z++; break;
	    case 4: ADDR2=1; ADDR1=0; ADDR0=0; Refresh(); z++; break;
			case 5: ADDR2=1; ADDR1=0; ADDR0=1; Refresh(); z++; break;
			case 6: ADDR2=1; ADDR1=1; ADDR0=0; Refresh(); z++; break;
	    case 7: ADDR2=1; ADDR1=1; ADDR0=1; Refresh(); z=0; break; 
	    default: z=0; break;
    }
	TR0 = 1;
	Light_Con = 0;
}
void Timer0Init(void)		//2ms@22.1184MHz
{
	AUXR |= 0x80;		//?????1T??
	TMOD &= 0xF0;		//???????
	TMOD |= 0x01;		//???????
	TL0 = 0x33;		//??????
	TH0 = 0x53;		//??????
	TF0 = 0;		//??TF0??
	TR0 = 1;
}
void Refresh()
{
	unsigned char LatchUpdate;
	for(LatchUpdate=0; LatchUpdate<24; LatchUpdate++)
	{
		SHCP = 0;
		STCP = 0;
		DS0 = (LatchUpdate==0) ? 1 : 0;
		SHCP = 1;
		STCP = 1;
		P0 = DatP0[z][LatchUpdate];
	} 
}
void TransCode() //转码函数
{
	int i,j;
	for(i=0;i<8;i++)
	{
		for(j=0;j<24;j++)
		{
			DatP0[i][j] = TransCodeChart[DatP0[i][j]];
		}
	}
}
void LedLocationIntoDatP0()	//将位置转化为锁存器数据
{
	unsigned char volatile i, LatchNum=0, color, LatchSum=0, LatchValue=0, LatchCompensation;
	unsigned char volatile LatchBit=0, n;
	unsigned char LatchBin[8]={1, 1, 1, 1, 1, 1, 1, 1};
	for(i=0; i<LED_NUM; i++)
	{
		for(n=0;n<8;n++)
		{
			LatchBin[n] = 1;
		}
		x = LedLocation[i][0];
		y = LedLocation[i][1];
		z = LedLocation[i][2];
		color = LedLocation[i][3];
		switch(color)
		{
			case 'B': LatchCompensation = 0; break;
			case 'G': LatchCompensation = 1; break;
			case 'R': LatchCompensation = 2; break;
			default: break;
		}
		// 分成y==2,y==5,其它三种情况讨论是第几个锁存器
		if(y==2)
		{
			if(color == 'R')
			{
				LatchNum = x*3+y/3+1;
			}
			else
			{
				LatchNum =  x*3+y/3;
			}
		}
		else if(y==5)
		{
			if(color=='R' | color=='G')
			{
				LatchNum = x*3+y/3+1;
			}
			else
			{
				LatchNum =  x*3+y/3;
			}
		}
		else 
		{
			LatchNum =  x*3+y/3;
		}
		LatchBit = y*3%8+LatchCompensation;
		LatchBin[LatchBit] = 0;
		LatchValue = LatchBin[0]*128 + LatchBin[1]*64 + LatchBin[2]*32 + LatchBin[3]*16 +
								LatchBin[4]*8 + LatchBin[5]*4 + LatchBin[6]*2 + LatchBin[7]*1;
		DatP0[z][LatchNum] = LatchValue & DatP0[z][LatchNum];
	}
}
void HorizontalRefresh(unsigned char zHorizontal, unsigned int colorHorizontal)
{
	unsigned char i, j, HorizontalLatchCompensation=0, HorizontalLatchBit=0;
	unsigned char LatchHorizontalBit[8] = {1,1,1,1,1,1,1,1};
	
	switch(colorHorizontal)
	{
		case 'B': 
			for(i=0;i<24;i++)
			{
				if(i%3 == 0)
				{
					DatP0[i] = 0x6D;
				}
				else if(i%3 == 1)
				{
					DatP0[i] = 0xB6;
				}
				else 
				{
					DatP0[i] = 0xDB;
				}
			}
			break;
		case 'G': 
			for(i=0;i<24;i++)
			{
				if(i%3 == 0)
				{
					DatP0[i] = 0xB6;
				}
				else if(i%3 == 1)
				{
					DatP0[i] = 0xDB;
				}
				else 
				{
					DatP0[i] = 0x6D;
				}
			}
			break;
		case 'R': 
			for(i=0;i<24;i++)
			{
				if(i%3 == 0)
				{
					DatP0[i] = 0xDB;
				}
				else if(i%3 == 1)
				{
					DatP0[i] = 0x6D;
				}
				else 
				{
					DatP0[i] = 0xB6;
				}
			}
			break;
		case "BG"
	}
		
}
void VerticalRefresh()